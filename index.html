<!DOCTYPE html>
<html>
<head>
    <title>Burgundy & Beige Psychedelic Animations</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: black; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 100;
            max-width: 300px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            background: #800020; /* Burgundy */
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: bold;
        }
        button:hover {
            background: #9c2743;
        }
        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            vertical-align: middle;
            border: 1px solid white;
        }
    </style>
</head>
<body>
    <canvas id="turtleCanvas"></canvas>
    
    <div class="controls">
        <h2>Psychedelic Controls</h2>
        
        <div class="control-group">
            <label for="color1">Primary Color (Burgundy)</label>
            <input type="range" id="color1" min="0" max="360" value="340">
            <span id="color1Preview" class="color-preview"></span>
        </div>
        
        <div class="control-group">
            <label for="color2">Secondary Color (Beige)</label>
            <input type="range" id="color2" min="0" max="360" value="45">
            <span id="color2Preview" class="color-preview"></span>
        </div>
        
        <div class="control-group">
            <label for="speed">Animation Speed</label>
            <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
        </div>
        
        <div class="control-group">
            <label for="complexity">Pattern Complexity</label>
            <input type="range" id="complexity" min="1" max="30" value="16">
        </div>
        
        <div class="control-group">
            <label for="lineWidth">Line Width</label>
            <input type="range" id="lineWidth" min="0.5" max="5" value="1" step="0.1">
        </div>
        
        <button id="downloadBtn">Download 7-second WEBM</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/whammy@0.0.2/whammy.min.js"></script>
    <script>
        const canvas = document.getElementById('turtleCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Center of the canvas
        let centerX = canvas.width / 2;
        let centerY = canvas.height / 2;
        
        // Turtle-like functions
        let angle = 0;
        let x = centerX;
        let y = centerY;
        let penDown = true;
        let color = [0, 0, 0];
        
        // Animation variables
        let animationId = null;
        let time = 0;
        let frames = [];
        let isRecording = false;
        let recordingStartTime = 0;
        const recordingDuration = 7000; // 7 seconds
        
        // Default settings
        let settings = {
            color1: 340, // Burgundy
            color2: 45,  // Beige
            speed: 1,
            complexity: 16,
            lineWidth: 1
        };
        
        // UI elements
        const color1Slider = document.getElementById('color1');
        const color2Slider = document.getElementById('color2');
        const speedSlider = document.getElementById('speed');
        const complexitySlider = document.getElementById('complexity');
        const lineWidthSlider = document.getElementById('lineWidth');
        const downloadBtn = document.getElementById('downloadBtn');
        const color1Preview = document.getElementById('color1Preview');
        const color2Preview = document.getElementById('color2Preview');
        
        // Update color previews
        function updateColorPreviews() {
            color1Preview.style.backgroundColor = `hsl(${settings.color1}, 100%, 50%)`;
            color2Preview.style.backgroundColor = `hsl(${settings.color2}, 100%, 50%)`;
        }
        
        // Set color based on HSV
        function setColor(c) {
            color = c;
            ctx.strokeStyle = `rgb(${Math.floor(c[0]*255)}, ${Math.floor(c[1]*255)}, ${Math.floor(c[2]*255)})`;
        }
        
        // Turtle movement functions
        function forward(dist) {
            const newX = x + dist * Math.cos(angle * Math.PI / 180);
            const newY = y + dist * Math.sin(angle * Math.PI / 180);
            
            if (penDown) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(newX, newY);
                ctx.stroke();
            }
            
            x = newX;
            y = newY;
        }
        
        function circle(radius, extent) {
            if (!penDown) return;
            
            const startAngle = angle - 90;
            const endAngle = startAngle + extent;
            const clockwise = extent < 0;
            
            ctx.beginPath();
            ctx.arc(x, y, Math.abs(radius), 
                   (startAngle) * Math.PI / 180, 
                   (endAngle) * Math.PI / 180, 
                   clockwise);
            ctx.stroke();
            
            // Update position to end of arc
            angle += extent;
            x += radius * Math.cos(angle * Math.PI / 180) - radius * Math.cos((angle - extent) * Math.PI / 180);
            y += radius * Math.sin(angle * Math.PI / 180) - radius * Math.sin((angle - extent) * Math.PI / 180);
        }
        
        function rt(degrees) {
            angle += degrees;
        }
        
        function lt(degrees) {
            angle -= degrees;
        }
        
        // HSV to RGB conversion
        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            
            return [r, g, b];
        }
        
        // Get interpolated color between two hues
        function getInterpolatedColor(t, hue1, hue2) {
            // Convert t to oscillating value between 0 and 1
            const oscillatingT = 0.5 + 0.5 * Math.sin(t * 0.01 * settings.speed);
            
            // Interpolate between the two hues
            const hue = hue1 + oscillatingT * (hue2 - hue1);
            
            // Convert to RGB via HSV
            return hsvToRgb((hue % 360) / 360, 1, 1);
        }
        
        // Main drawing function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = settings.lineWidth;
            x = centerX;
            y = centerY;
            angle = 0;
            
            // Update settings from sliders
            settings.color1 = parseInt(color1Slider.value);
            settings.color2 = parseInt(color2Slider.value);
            settings.speed = parseFloat(speedSlider.value);
            settings.complexity = parseInt(complexitySlider.value);
            settings.lineWidth = parseFloat(lineWidthSlider.value);
            
            updateColorPreviews();
            
            for (let i = 0; i < settings.complexity; i++) {
                for (let j = 0; j < 18; j++) {
                    const c = getInterpolatedColor(time + i * 10 + j * 5, settings.color1, settings.color2);
                    setColor(c);
                    
                    rt(90);
                    circle(150 - j * 6, 90);
                    lt(90);
                    circle(150 - j * 6, 90);
                    rt(180);
                }
                circle(40, 24);
            }
            
            time += 1;
            
            // If recording, capture frames
            if (isRecording) {
                const elapsed = Date.now() - recordingStartTime;
                if (elapsed < recordingDuration) {
                    frames.push(canvas.toDataURL('image/webp'));
                    animationId = requestAnimationFrame(draw);
                } else {
                    stopRecording();
                }
            } else {
                animationId = requestAnimationFrame(draw);
            }
        }
        
        // Start recording animation
        function startRecording() {
            isRecording = true;
            recordingStartTime = Date.now();
            frames = [];
            downloadBtn.disabled = true;
            downloadBtn.textContent = "Recording...";
            draw(); // Start the drawing loop
        }
        
        // Stop recording and create video
        function stopRecording() {
            isRecording = false;
            cancelAnimationFrame(animationId);
            
            // Create video from frames
            const video = Whammy.fromImageArray(frames, 30); // 30 fps
            
            // Create download link
            const blob = new Blob([video], {type: 'video/webm'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'psychedelic-animation.webm';
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            downloadBtn.disabled = false;
            downloadBtn.textContent = "Download 7-second WEBM";
            
            // Restart normal animation
            animationId = requestAnimationFrame(draw);
        }
        
        // Event listeners
        downloadBtn.addEventListener('click', startRecording);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
        });
        
        // Initialize
        updateColorPreviews();
        draw();
    </script>
</body>
</html>
